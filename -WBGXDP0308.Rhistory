travel_vals <- extract(acc_cost, grid_vect)
# Combine into a data.frame
df <- data.frame(
h3_id = grid_sub$h3_id,
travel_time_min = travel_vals[, 2],
ID_ADM = poly_id
)
return(df)
}
## Run across all ADM2 units
progressr::with_progress({
p <- progressor(along = 1:nrow(adm2))
results <- lapply(seq_len(nrow(adm2)), function(i) {
p()
compute_travel_time_adm2(adm2, i)
})
})
packageVersion("terra")
## Load Packages
pacman::p_load(sf, terra, dplyr, h3jsr, progressr, data.table, readr)
## Set CRS
crs_utm38 <- "EPSG:32638"
## Define Paths
friction_dir  <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/Market_access_raster"
markets_csv <- file.path(markets_dir, "Marketpoints.csv")
## Define Paths
markets_dir   <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/spatial/Marketpoints"
friction_dir  <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/Market_access_raster"
markets_csv <- file.path(markets_dir, "Marketpoints.csv")
adm2_shp    <- file.path(shapefile_dir, "Admin2.geojson")
tt_mixed_100_hrs  <- file.path(friction_dir, "tt_mixed_yem_100_hrs.tif")
shapefile_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/101_admin"
markets_csv <- file.path(markets_dir, "Marketpoints.csv")
adm2_shp    <- file.path(shapefile_dir, "Admin2.geojson")
tt_mixed_100_hrs  <- file.path(friction_dir, "tt_mixed_yem_100_hrs.tif")
fric_raster <- rast(tt_mixed_100_hrs)
adm2 <- st_read(adm2_shp, quiet = TRUE) |> st_transform(crs_utm38)
mkts <- read_csv(markets_csv) |>
st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) |>
st_transform(crs_utm38)
plot(fric_raster)
## Clip and mask raster
# Step 1: Convert adm2 to SpatVector (terra format)
adm2_vect <- vect(adm2)
# Step 2: Crop the raster to the extent of the adm2 shapefile (optional, for speed)
fric_crop <- crop(fric_raster, adm2_vect)
# Step 3: Mask the cropped raster using adm2 geometry
fric_mask <- mask(fric_crop, adm2_vect)
# Step 4 (Optional): Plot to check results
plot(fric_mask)
pop_rast <- file.path(population_dir, "ppp_2020_1km_Aggregated.tif")
population_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/103_worldpop_population"
pop_rast <- file.path(population_dir, "ppp_2020_1km_Aggregated.tif")
pop2020 <- rast([pop_rast])
pop2020 <- rast(pop_rast)
## Load Packages
pacman::p_load(sf, terra, dplyr, readr)
## Set CRS
crs_utm38 <- "EPSG:32638"
## Define Paths
markets_dir   <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/spatial/Marketpoints"
friction_dir  <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/Market_access_raster"
shapefile_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/101_admin"
population_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/103_worldpop_population"
adm2_shp    <- file.path(shapefile_dir, "Admin2.geojson")
tt_mixed_100_hrs  <- file.path(friction_dir, "tt_mixed_yem_100_hrs.tif")
pop_rast <- file.path(population_dir, "ppp_2020_1km_Aggregated.tif")
## Load Data
fric_raster <- rast(tt_mixed_100_hrs)
pop2020 <- rast(pop_rast)
adm2 <- st_read(adm2_shp, quiet = TRUE) |> st_transform(crs_utm38)
adm2_vect <- vect(adm2)
## Clip and Mask Travel Time Raster to ADM2 Extent
fric_crop <- crop(fric_raster, adm2_vect)
fric_mask <- mask(fric_crop, adm2_vect)
plot(fric_mask)
plot(fric_mask)
## Step 1: Aggregate 100m travel time to 1km resolution using mean
fric_1km_mean <- aggregate(fric_mask, fact = 10, fun = mean, na.rm = TRUE)
## Step 2: Resample population raster to match travel time raster (1km)
pop_resampled <- resample(pop2020, fric_1km_mean, method = "bilinear")
## Step 3: Create mask for cells with 0 < travel time < 2 hour
access_mask <- fric_1km_mean < 2 & fric_1km_mean > 0
## Step 4: Mask population raster using access mask
pop_access <- mask(pop_resampled, access_mask, maskvalues = FALSE)
# Ensure both rasters are in same CRS
if (crs(fric_raster) != crs_utm38) crs(fric_raster) <- crs_utm38
if (crs(pop2020) != crs_utm38) pop2020 <- project(pop2020, crs_utm38)
## Clip and Mask Travel Time Raster to ADM2 Extent
fric_crop <- crop(fric_raster, adm2_vect)
fric_mask <- mask(fric_crop, adm2_vect)
plot(fric_mask)
## Step 1: Aggregate 100m travel time to 1km resolution using mean
fric_1km_mean <- aggregate(fric_mask, fact = 10, fun = mean, na.rm = TRUE)
## Step 2: Resample population raster to match travel time raster (1km)
pop_resampled <- resample(pop2020, fric_1km_mean, method = "bilinear")
## Step 3: Create mask for cells with 0 < travel time < 2 hour
access_mask <- fric_1km_mean < 2 & fric_1km_mean > 0
## Step 4: Mask population raster using access mask
pop_access <- mask(pop_resampled, access_mask, maskvalues = FALSE)
## Step 5: Extract total population per ADM2
pop_total_by_adm2 <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
rename(total_pop = sum)
## Step 6: Extract population totals by ADM2
pop_total_by_adm2 <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE)
pop_access_by_adm2 <- extract(pop_access, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE)
# Convert to data frames and rename columns
pop_total_df <- st_drop_geometry(pop_total_by_adm2) |>
rename(total_pop = sum)
# Convert to data frames and rename columns
pop_total_df <- st_drop_geometry(pop_total_by_adm2) |>
dplyr::rename(total_pop = sum)
# Convert to data frames from SpatVector
pop_total_df <- as.data.frame(pop_total_by_adm2) |>
dplyr::rename(total_pop = sum)
## Step 6: Extract population totals by ADM2
pop_total_by_adm2 <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE)
pop_access_by_adm2 <- extract(pop_access, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE)
# Convert to data frames from SpatVector
pop_total_df <- as.data.frame(pop_total_by_adm2) |>
dplyr::rename(total_pop = sum)
## Step 6: Extract total and accessible population per ADM2
pop_total_df <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_total_df)[2] <- "total_pop"
pop_access_df <- extract(pop_access, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_access_df)[2] <- "accessible_pop"
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "ID") |>
mutate(
percent_access = 100 * accessible_pop / total_pop,
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
View(pop_access_df)
View(pop_total_df)
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "admin2Pcod") |>
mutate(
percent_access = 100 * accessible_pop / total_pop,
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "admin2Pcod") |>
mutate(
percent_access = 100 * (accessible_pop / total_pop ),
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "admin2Pcod") |>
mutate(
total_pop = as.numeric(total_pop),
accessible_pop = as.numeric(accessible_pop),
percent_access = 100 * (accessible_pop / total_pop),
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
View(pop_summary)
pop_total_df <- pop_total_df |>
mutate(total_pop = as.numeric(total_pop))
## Step 6: Extract total and accessible population per ADM2
pop_total_df <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_total_df)[2] <- "total_pop"
## Step 6: Extract total and accessible population per ADM2
pop_total_df <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_total_df)[6] <- "total_pop"
pop_access_df <- extract(pop_access, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_access_df)[6] <- "accessible_pop"
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "admin2Pcod") |>
mutate(
percent_access = 100 * (accessible_pop / total_pop),
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
## Load Packages
pacman::p_load(sf, terra, dplyr, readr)
## Set CRS
crs_utm38 <- "EPSG:32638"
## Define Paths
markets_dir   <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/spatial/Marketpoints"
friction_dir  <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/150_icl_access_to_markets/Market_access_raster"
shapefile_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/101_admin"
population_dir <- "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - Yemen Poverty Team FY23/Poverty Assessment/data/GIS/1_Original_Data/103_worldpop_population"
adm2_shp    <- file.path(shapefile_dir, "Admin2.geojson")
tt_mixed_100_hrs  <- file.path(friction_dir, "tt_mixed_yem_100_hrs.tif")
pop_rast <- file.path(population_dir, "ppp_2020_1km_Aggregated.tif")
## Load Data
fric_raster <- rast(tt_mixed_100_hrs)
pop2020 <- rast(pop_rast)
adm2 <- st_read(adm2_shp, quiet = TRUE) |> st_transform(crs_utm38)
adm2_vect <- vect(adm2)
# Ensure both rasters are in same CRS
if (crs(fric_raster) != crs_utm38) crs(fric_raster) <- crs_utm38
if (crs(pop2020) != crs_utm38) pop2020 <- project(pop2020, crs_utm38)
rm(pop_summary)
## Step 6: Extract total and accessible population per ADM2
pop_total_df <- extract(pop_resampled, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_total_df)[6] <- "total_pop"
pop_access_df <- extract(pop_access, adm2_vect, fun = sum, na.rm = TRUE, bind = TRUE) |>
as.data.frame()
names(pop_access_df)[6] <- "accessible_pop"
## Step 7: Join and calculate percent access
pop_summary <- left_join(pop_total_df, pop_access_df, by = "admin2Pcod") |>
mutate(
percent_access = 100 * (accessible_pop / total_pop),
percent_access = ifelse(is.nan(percent_access), NA, percent_access)
)
View(pop_summary)
## Step 8 (Optional): Join back to ADM2 geometry for mapping or export
adm2_summary <- left_join(adm2, pop_summary, by = "admin2Pcod")
View(adm2_summary)
## Step 9 (Optional): View or export
head(adm2_summary[, c("admin2Pcod", "total_pop", "accessible_pop", "percent_access")])
## Load Packages
pacman::p_load(sf, terra, dplyr, readr,tmap)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% pop. with access <1hr",
palette = "Blues",
style = "quantile",   # or "cont" for continuous scale
n = 5,
textNA = "No data",
colorNA = "gray80"
) +
tm_layout(
title = "Market Access within 1 Hour (ADM2)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% pop. with access <2hr",
palette = "Blues",
style = "quantile",   # or "cont" for continuous scale
n = 5,
textNA = "No data",
colorNA = "gray80"
) +
tm_layout(
title = "Share of Population with Market Access Within 1 Hour (Driving + Walking) (ADM2)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% pop. with access <2hr",
palette = "Blues",
style = "quantile",   # or "cont" for continuous scale
n = 5,
textNA = "No data",
colorNA = "gray80"
) +
tm_layout(
title = "% of Population with Market Access Within 1 Hour (Driving + Walking) (ADM2)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE,
title.position = c("center", "top")
)
## Load Packages
pacman::p_load(sf, terra, dplyr, readr,tmap, viridis)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE,
title.position = c("center", "top")
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access\n<= 2 hours",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access\nwithin 2 hours of driving + walking",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access\nwithin 2 hours",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <1 Hour (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE
)
tm_shape(adm2_summary) +
tm_polygons(
"percent_access",
title = "% of population with access\nwithin 2 hours",
palette = viridis(5, option = "D", direction = -1),  # 5-step viridis, reversed
style = "quantile",
n = 5,
textNA = "No data",
colorNA = "gray90"
) +
tm_layout(
title = "Share of Population Within Each ADM2 with Market Access <2 Hours (Driving + Walking)",
legend.outside = TRUE,
frame = FALSE
)
knitr::opts_chunk$set(echo = TRUE)
devtools::install_github("arthur-shaw/susoapi")
install.packages("devtools")
devtools::install_github("arthur-shaw/susoapi")
set_credentials(
server = "yemenhbs2025-demo",
workspace = "yemenhbs_supv",
user = "yemenhbs_api",
password = "yemenHBS2025!"
)
devtools::install_github("arthur-shaw/susoapi")
devtools::install_github("arthur-shaw/susoapi",force = TRUE)
set_credentials(
server = "yemenhbs2025-demo",
workspace = "yemenhbs_supv",
user = "yemenhbs_api",
password = "yemenHBS2025!"
)
pacman::p_load(
sf, terra, raster, gdistance, dplyr, readr, h3jsr, progress, parallel,
igraph, ggplot2, viridis, data.table
)
## 1 · Paths ----------------------------------------------------------
friction_dir  <-  "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - 150_icl_access_to_markets/Market_access_raster"
roads_dir     <-  "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - 150_icl_access_to_markets/blocked_roads"
output_path   <-  file.path(friction_dir, "fric_mx_roads_updated.tif")
## 2 · Read inputs ----------------------------------------------------
fric_mx        <- rast(file.path(friction_dir, "ymn_mx"))
## 2 · Read inputs ----------------------------------------------------
fric_mx        <- rast(file.path(friction_dir, "ymn_mx"))
roads          <- st_read(file.path(roads_dir, "yem_roads.shp"))
roads_opened   <- st_read(file.path(roads_dir, "non_passable_combined.shp"))
boundary_aoc   <- st_read(file.path(roads_dir, "shared_boundary.shp"))
## 3 · Filter and convert roads ---------------------------------------
blocked_roads       <- roads %>% filter(Crrnt_s == "Not Passable")
blocked_roads_vect  <- vect(blocked_roads)
roads_opened_vect   <- vect(roads_opened)
boundary_aoc_vect   <- vect(boundary_aoc)
# Combine and project
all_roads_vect <- rbind(blocked_roads_vect, roads_opened_vect)
all_roads_vect <- project(all_roads_vect, crs(fric_mx))
## 4 · Buffer and rasterize to disk -----------------------------------
# Slight buffer to ensure raster overlap
all_roads_buff <- buffer(all_roads_vect, width = 100)
# Save rasterized mask directly to disk
road_mask_path <- file.path(friction_dir, "road_mask_temp.tif")
road_mask <- rasterize(all_roads_buff, fric_mx, field = 1, filename = road_mask_path, overwrite = TRUE)
## 5 · Replace values and write output to disk ------------------------
global_max <- global(fric_mx, fun = "max", na.rm = TRUE)[1, 1]
fric_mx_updated <- ifel(!is.na(rast(road_mask_path)), global_max, fric_mx)
writeRaster(fric_mx_updated, output_path, overwrite = TRUE)
# Optional: Verify replacement
vals <- extract(fric_mx_updated, all_roads_buff)[[2]]
table(round(vals, 5))
# ====================================================================
#  Travel-time to the nearest market (minutes)  ·  Yemen
#  Author   : Chitra Balasubramanian
#  Date     : 2025-06-02   (updated with H3 grid indexing)
#  Purpose  : Assign high values to areas of control and blocked roads
# ====================================================================
## 0 · Packages -------------------------------------------------------
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
sf, terra, raster, gdistance, dplyr, readr, h3jsr, progress, parallel,
igraph, ggplot2, viridis, data.table
)
## 1 · Paths ----------------------------------------------------------
friction_dir  <-  "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - 150_icl_access_to_markets/Market_access_raster"
roads_dir     <-  "C:/Users/wb569257/OneDrive - WBG/Alia Jane Aghajanian's files - 150_icl_access_to_markets/blocked_roads"
output_path   <-  file.path(friction_dir, "fric_mx_roads_updated.tif")
## 2 · Read inputs ----------------------------------------------------
fric_mx        <- rast(file.path(friction_dir, "ymn_mx"))
roads          <- st_read(file.path(roads_dir, "yem_roads.shp"))
roads_opened   <- st_read(file.path(roads_dir, "non_passable_combined.shp"))
boundary_aoc   <- st_read(file.path(roads_dir, "shared_boundary.shp"))
## 3 · Filter and convert roads ---------------------------------------
blocked_roads       <- roads %>% filter(Crrnt_s == "Not Passable")
blocked_roads_vect  <- vect(blocked_roads)
roads_opened_vect   <- vect(roads_opened)
boundary_aoc_vect   <- vect(boundary_aoc)
# Combine and project
all_roads_vect <- rbind(blocked_roads_vect, roads_opened_vect)
all_roads_vect <- project(all_roads_vect, crs(fric_mx))
## 4 · Buffer and rasterize to disk -----------------------------------
# Slight buffer to ensure raster overlap
all_roads_buff <- buffer(all_roads_vect, width = 100)
# Save rasterized mask directly to disk
road_mask_path <- file.path(friction_dir, "road_mask_temp.tif")
road_mask <- rasterize(all_roads_buff, fric_mx, field = 1, filename = road_mask_path, overwrite = TRUE)
## 5 · Replace values and write output to disk ------------------------
global_max <- global(fric_mx, fun = "max", na.rm = TRUE)[1, 1]
fric_mx_temp <- ifel(!is.na(rast(road_mask_path)), global_max, fric_mx)
# Assign smaller values to AOC --------------------------------------------
# Project boundary if needed
boundary_aoc_vect <- project(boundary_aoc_vect, crs(fric_mx))
# Buffer boundary to ensure it hits raster cells
boundary_buff <- buffer(boundary_aoc_vect, width = 100)
# Rasterize to disk
boundary_mask_path <- file.path(friction_dir, "boundary_mask_temp.tif")
boundary_mask <- rasterize(boundary_buff, fric_mx, field = 1, filename = boundary_mask_path, overwrite = TRUE)
# Replace raster values where boundary intersects with 3
fric_mx_updated <- ifel(!is.na(rast(boundary_mask_path)), 3, fric_mx_temp)
# Final write
writeRaster(fric_mx_updated, output_path, overwrite = TRUE)
fric_mx_updated <- ifel(!is.na(rast(road_mask_path)), global_max, fric_mx)
# Extract and tabulate values under roads and boundary
vals_roads <- extract(fric_mx_updated, all_roads_buff)[[2]]
vals_boundary <- extract(fric_mx_updated, boundary_buff)[[2]]
cat("🚗 Road Buffer Values:\n")
print(table(round(vals_roads, 5)))
cat("\n🟦 Boundary Buffer Values:\n")
print(table(round(vals_boundary, 5)))
# Logical checks
cat("\n✅ Are all road values == global_max?\n")
print(all(round(vals_roads, 5) == round(global_max, 5)))
cat("\n✅ Are all boundary values == 3?\n")
print(all(round(vals_boundary, 5) == 3))
print(table(round(vals_roads, 5)))
# Plot the updated raster
plot(fric_mx_updated, main = "Updated Raster: Roads vs. Boundary Assignments")
# Add all roads (buffered), in red
plot(all_roads_buff, col = "red", add = TRUE)
# Add boundary (buffered), in blue
plot(boundary_buff, col = "blue", add = TRUE)
# After the roads opened --------------------------------------------------
roads_opened_vect <-  project(all_roads_vect, crs(fric_mx_updated))
# Slight buffer to ensure raster overlap
roads_opened_buff <- buffer(roads_opened_vect, width = 100)
road_mask_path <- file.path(friction_dir, "roads_opened_mask_temp.tif")
road_opened_mask_path <- file.path(friction_dir, "roads_opened_mask_temp.tif")
road_opened_mask <- rasterize(roads_opened_buff, fric_mx_updated, field = 1, filename = road_mask_path, overwrite = TRUE)
fric_mx_roads_opened <- ifel(!is.na(rast(road_opened_mask_path)), fric_mx, fric_mx_updated) # since road is opened I want those parts to take original raster value
output_path_road_opened <- file.path(friction_dir, "fric_mx_roads_opened.tif")
#check
vals_roads_opened <- extract(fric_mx_roads_opened, roads_opened_buff)[[2]]
print(table(round(vals_roads_opened, 5)))
# Final write
writeRaster(fric_mx_roads_opened, output_path, overwrite = TRUE)
# Final write
writeRaster(fric_mx_roads_opened, output_path_road_opened, overwrite = TRUE)
